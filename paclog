#!/usr/bin/python

from sys import stderr, exit, exc_info
from argparse import ArgumentParser
from re import compile, search
from os import getuid


def main():
    args = argparser()

    global log_file
    log_file = args.file if args.file else get_log_file()

    global red, green, blue, cyan, reset
    if args.color:
        red, green = '\033[31m', '\033[32m'
        blue, cyan = '\033[34m', '\033[36m'
        reset = '\033[0m'
    else:
        red = green = blue = cyan = reset = ''
    
    filters = {
        'in': 'installed',
        'rm': 'removed',
        'up': 'upgraded'
    }

    if args.clean:
        clean()
        print(f'{log_file} cleaned')
        exit(0)
    elif args.show:
        print(get_log_file())
        exit(0)
    elif args.raw:
        raw()
        exit(0)

    p = compile(r'^\[(?P<y>\d+)-(?P<m>\d+)-(?P<d>\d+)'
                r'T(?P<hour>\d+):(?P<minute>\d+):.*\] '
                r'\[ALPM\] '
                r'(?P<op>installed|removed|upgraded) '
                r'(?P<pkg>.*) \((?P<ver>.*)\)$')
        
    pkg = compile(r'^\[.*\] \[ALPM\] '
                  r'(installed|removed|upgraded) (?P<pkg>.*) '
                  r'\(.*\)$')

    try:        
        with open(log_file, 'r') as f:
            max_len = 0
            for line in f:
                if m := pkg.match(line):
                    length = len(m['pkg'])
                    if length > max_len:
                        max_len = length
            
            f.seek(0)
            for line in f:
                if m := p.match(line):
                    if(not search(args.package, m['pkg']) or
                            args.filter and filters[args.filter] != m['op']):
                        continue
                    
                    if args.short:
                        if m['op'] == 'installed':
                            print(f'{green}+{reset}', end='  ')
                        elif m['op'] == 'removed':
                            print(f'{red}-{reset}', end='  ')
                        elif m['op'] == 'upgraded':
                            print(f'{blue}>{reset}', end='  ')
                    else:
                        print(f"{m['d']}/{m['m']}/{m['y']}  "
                              f"{m['hour']}:{m['minute']}", end='  ')

                        if m['op'] == 'installed':
                            print(f'{green}installed{reset}', end='  ')
                        elif m['op'] == 'removed':
                            print(f'{red}removed{reset}  ', end='  ')
                        elif m['op'] == 'upgraded':
                            print(f'{blue}upgraded{reset} ', end='  ')
                    
                    spaces = ' ' * (max_len - len(m['pkg']) + 2)
                    print(m['pkg'] + spaces + cyan + m['ver'] + reset)
    except IOError:
        die(f'cannot read {log_file}')
    except:
        die(exc_info()[1])


def argparser():
    parser = ArgumentParser(prog='paclog')
    parser.add_argument('package', action='store', type=str, nargs='?',
                        default='.*',
                        help='a regular expression for the package search')
    parser.add_argument('--file', action='store', type=str,
                        help='use an alternate log file')
    parser.add_argument('-f', dest='filter', choices=['in', 'rm', 'up'],
                        help='filter operations')
    parser.add_argument('-s', '--short', action='store_true',
                        help='enable less verbose mode')
    parser.add_argument('--show', action='store_true',
                        help='show default log file and exit')
    parser.add_argument('--raw', action='store_true',
                        help='read log file and exit')
    parser.add_argument('--clean', action='store_true',
                        help='clean log file and exit')
    parser.add_argument('-c', '--color', action='store_true',
                        help='colorize the output')
    parser.add_argument('--version', action='version', version='%(prog)s 1.1')
    return parser.parse_args()


def raw():
    try:
        with open(log_file, 'r') as f:
            for line in f:
                print(line, end='')
    except:
        die(f'cannot read {log_file}')


def clean():
    if getuid() != 0:
        die('you cannot perform this operation unless you are root')
    try:
        with open(log_file, 'r+') as f:
            f.truncate(0)
    except:
        die(f'cannot clean {log_file}')


def get_log_file():
    conf = '/etc/pacman.conf'
    try:
        p = compile(r'^LogFile\s*=\s*(?P<path>.*)$')
        with open(conf, 'r') as f:
            for line in f:
                if m := p.match(line):
                    return m['path']
    except:
        die(f'cannot parse {conf}')
    
    return '/var/log/pacman.log'


def die(msg):
    print(f'{red}error:{reset} {msg}', file=stderr)
    exit(1)

if __name__ == '__main__':
    main()
